<!doctype html>
<html>

<head>

  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>XCDL packages</title>
  <meta name="description" content="The eXtensible Component Definition Language.">

  <meta property="og:title" content="XCDL packages" />
  <meta property="og:site_name" content="XCDL" />

  <link rel="alternate" type="application/rss+xml" title="XCDL" href="/feed.xml" />








  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css?201510121951" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/print.css?201510121951" media="print">

  <link rel="canonical" href="http://ilg-ul.github.io/guide/packages/">



  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-16767008-13', 'auto');
  ga('send', 'pageview');

</script>



</head>


<body>

<div class="container">

  <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

  <div class="site-header">
  <img class="site-icon" src="/assets/icons/components.png" height="100" width="100">
  <div class="site-title">
    <h1><a href="/">XCDL</a></h1>
    <p>The eXtensible Component Definition Language.</p>
  </div>
</div>


</div>

<div class="container">

  <div class="wrapper">
    <div class="site-body">

      <div class="site-sidebar">


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="xcdl-newsblog"><a href="/blog/">XCDL News</a></h4>

<ul>
  <li><a href="/blog/2015/10/12/github-pages/">The GitHub Wiki content was migrated to GitHub Pages</a></li>
  <li><a href="/blog/2015/09/26/github-wiki/">The XCDL Wiki content was migrated from MediaWiki to GitHub Wiki</a></li>
</ul>


    </div>
  </div>


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="xcdl-home"><a href="/">XCDL Home</a></h4>

<h4 id="component-writers-guide">Component Writer’s Guide</h4>
<ul>
  <li><a href="/guide/concepts/">XCDL Concepts</a></li>
  <li><a href="/guide/packages/">XCDL Packages</a></li>
  <li><a href="/guide/repositories/">XCDL Repositories</a></li>
  <li><a href="/guide/language/">XCDL Language</a></li>
  <li><a href="/guide/build-process/">The build process</a></li>
</ul>

<h4 id="reference">Reference</h4>
<ul>
  <li><a href="/reference/language/">XCDL language</a></li>
</ul>

<h4 id="license">License</h4>

<ul>
  <li><a href="https://www.gnu.org/licenses/gpl.html">GPL</a></li>
</ul>

<h4 id="aboutabout"><a href="/about/">About</a></h4>

    </div>
  </div>

  <div class="site-theme">
    This site uses the <a href="https://github.com/ilg-ul/github-jekyll-theme">GitHub Wiki-like</a> theme by <a href="https://github.com/ilg-ul">Liviu Ionescu</a>.
  </div>

</div>


      <div class="site-content">

        
<h1 class="page-title">XCDL packages</h1>
<p class="last-modified">Last modified on Sun Oct 25 09:01:13 2015 UTC.</p>


<div id="toc-container">
<table class="toc" id="toc">
<tbody>
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toc_level-1 toc_section-1">
<a href="#packages"><span class="tocnumber">1</span> <span class="toctext">Packages</span></a>
<ul>
<li class="toc_level-2 toc_section-2">
<a href="#what-is-a-package"><span class="tocnumber">1.1</span> <span class="toctext">What is a package?</span></a>
</li>
<li class="toc_level-2 toc_section-3">
<a href="#package-contents"><span class="tocnumber">1.2</span> <span class="toctext">Package contents</span></a>
</li>
<li class="toc_level-2 toc_section-4">
<a href="#package-layout"><span class="tocnumber">1.3</span> <span class="toctext">Package layout</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-5">
<a href="#the-xpackagexml-file"><span class="tocnumber">2</span> <span class="toctext">The .xpackage.xml file</span></a>
<ul>
<li class="toc_level-2 toc_section-6">
<a href="#name"><span class="tocnumber">2.1</span> <span class="toctext">name</span></a>
</li>
<li class="toc_level-2 toc_section-7">
<a href="#description"><span class="tocnumber">2.2</span> <span class="toctext">description</span></a>
</li>
<li class="toc_level-2 toc_section-8">
<a href="#releases"><span class="tocnumber">2.3</span> <span class="toctext">releases</span></a>
</li>
<li class="toc_level-2 toc_section-9">
<a href="#keywords"><span class="tocnumber">2.4</span> <span class="toctext">keywords</span></a>
</li>
<li class="toc_level-2 toc_section-10">
<a href="#homepage"><span class="tocnumber">2.5</span> <span class="toctext">homepage</span></a>
</li>
<li class="toc_level-2 toc_section-11">
<a href="#bugs"><span class="tocnumber">2.6</span> <span class="toctext">bugs</span></a>
</li>
<li class="toc_level-2 toc_section-12">
<a href="#license"><span class="tocnumber">2.7</span> <span class="toctext">license</span></a>
</li>
<li class="toc_level-2 toc_section-13">
<a href="#maintainers"><span class="tocnumber">2.8</span> <span class="toctext">maintainers</span></a>
</li>
<li class="toc_level-2 toc_section-14">
<a href="#contributors"><span class="tocnumber">2.9</span> <span class="toctext">contributors</span></a>
</li>
<li class="toc_level-2 toc_section-15">
<a href="#repository"><span class="tocnumber">2.10</span> <span class="toctext">repository</span></a>
</li>
<li class="toc_level-2 toc_section-16">
<a href="#dependencies"><span class="tocnumber">2.11</span> <span class="toctext">dependencies</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-17">
<a href="#build"><span class="tocnumber">3</span> <span class="toctext">Build</span></a>
<ul>
<li class="toc_level-2 toc_section-18">
<a href="#build-artefact-types"><span class="tocnumber">3.1</span> <span class="toctext">Build artefact types</span></a>
</li>
<li class="toc_level-2 toc_section-19">
<a href="#outline-of-the-new-project-process"><span class="tocnumber">3.2</span> <span class="toctext">Outline of the new project process</span></a>
</li>
<li class="toc_level-2 toc_section-20">
<a href="#outline-of-the-build-process"><span class="tocnumber">3.3</span> <span class="toctext">Outline of the build process</span></a>
</li>
<li class="toc_level-2 toc_section-21">
<a href="#configurable-source-code"><span class="tocnumber">3.4</span> <span class="toctext">Configurable source code</span></a>
</li>
<li class="toc_level-2 toc_section-22">
<a href="#exported-header-files"><span class="tocnumber">3.5</span> <span class="toctext">Exported header files</span></a>
</li>
<li class="toc_level-2 toc_section-23">
<a href="#package-documentation"><span class="tocnumber">3.6</span> <span class="toctext">Package documentation</span></a>
</li>
<li class="toc_level-2 toc_section-24">
<a href="#test-cases"><span class="tocnumber">3.7</span> <span class="toctext">Test cases</span></a>
</li>
<li class="toc_level-2 toc_section-25">
<a href="#host-side-support"><span class="tocnumber">3.8</span> <span class="toctext">Host-side support</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-26">
<a href="#making-a-package-distribution"><span class="tocnumber">4</span> <span class="toctext">Making a package distribution</span></a>
<ul>
<li class="toc_level-2 toc_section-27">
<a href="#the-xcdl-package-distribution-file-format"><span class="tocnumber">4.1</span> <span class="toctext">The XCDL package distribution file format</span></a>
</li>
<li class="toc_level-2 toc_section-28">
<a href="#preparing-xcdl-packages-for-distribution"><span class="tocnumber">4.2</span> <span class="toctext">Preparing XCDL packages for distribution</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-29">
<a href="#credits"><span class="tocnumber">5</span> <span class="toctext">Credits</span></a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div><p>For a package to be usable in the XCDL component framework it must conform to certain rules imposed by the framework. Packages must be distributed in a form that is understood by the component repository administration tool. For each package there must be a top-level XCDL metadata file which describes the package to the component framework. There are certain portability requirements related to how a package gets built, so that the package can be used in a variety of host environments. In addition to these rules, the component framework provides a number of guidelines. It is not mandatory for the packages to strictly conform to all guidelines, but sticking to them can simplify certain operations.</p>

<h2 id="packages">Packages</h2>

<h3 id="what-is-a-package">What is a package?</h3>

<p>Inspired from the <a href="https://docs.npmjs.com/misc/developers#what-is-a-package">NPM</a> package definition, an XCDL package is:</p>

<ol>
  <li>a folder containing a valid <code>.xpackage.xml</code> file;</li>
  <li>a gzipped tarball containing 1);</li>
  <li>a URL that resolves to 2);</li>
  <li>a Git URL that, when cloned, results in 1).</li>
</ol>

<p>The definition is intentionally Git and JavaScript centric, as these technologies are considered mature and worth considering.</p>

<p>Although the XCDL language will probably remain based on XML, equivalent definitions can be expressed in JSON, and compatibility with JSON is considered a kind of validation that the definitions are simple and consistent.</p>

<h3 id="package-contents">Package contents</h3>

<p>In addition to the <code>.xpackage.xml</code> metadata file, a typical package contains the following:</p>

<ul>
  <li>some number of source files (.c/.cpp) and header files (.h). The project artefact (library or executable) will be created using these files. Some source files may serve other purposes, for example to provide a linker script;</li>
  <li>exported header files which define the interface provided by the package;</li>
  <li>online documentation, for example reference pages for each exported function;</li>
  <li>some number of test cases, shipped in source format, allowing users to check that the package is working as expected on their particular hardware and in their specific configuration;</li>
  <li>other XCDL metadata files describing the package to the configuration system.</li>
</ul>

<p>It is also conventional to have a per-package <code>ChangeLog</code> file used to keep track of changes to that package. This is especially valuable to end users of the package who may not have convenient access to the source code control system used to manage the master copy of the package, and hence cannot find out easily what has changed. Often it can be very useful to the main developers as well.</p>

<p>Any given packages need not contain all of these.</p>

<p>Some packages may not have any source code: it is possible to have a package that merely defines a common interface which can then be implemented by several other packages, especially in the context of device drivers; however it is still common to have some code in such packages to avoid replicating shareable code in all of the implementation packages. Similarly it is possible to have a package with no exported header files, just source code that implements an existing interface: for example an ethernet device driver might just implement a standard interface and not provide any additional functionality. Packages do not need to come with any on-line documentation, although this may affect how many people will want to use the package. Much the same applies to per-package test cases.</p>

<h3 id="package-layout">Package layout</h3>

<p>The component framework has a recommended per-package folder layout which splits the package contents on a functional basis:</p>

<pre>
<code>Packages/ilg/xyzw/current
├── .xpackage.xml
├── .xpackignore
├── ChangeLog
├── README.md
├── doc
├── include
├── src
└── tests
</code></pre>

<p>For example, if a package has an <code>include</code> sub-folder then the component framework will assume that all header files in and below that folder are <strong>exported header files</strong> and will do the right thing at build time. Similarly if there is <em>doc</em> property indicating the location of online documentation then the component framework will first look in the <code>doc</code> subfolder.</p>

<p>Except for the name and location of the <code>.xpackage.xml</code> file, this folder layout is just a guideline, it is not enforced by the component framework. For simple packages it often makes more sense to have all of the files in just one directory. For example a package could just contain the files hello.cpp, hello.h, hello.html. By default hello.h will be treated as an exported header file, although this can be overridden with the includeFiles property. Assuming there is a doc property referring to hello.html and there is no doc sub-directory then the tools will search for this file relative to the package’s top-level and everything will just work. Much the same applies to hello.cpp.</p>

<h2 id="the-xpackagexml-file">The <code>.xpackage.xml</code> file</h2>

<h3 id="name">
<code>name</code>
</h3>

<p>A string that, together with the <code>parent</code>, must uniquely identify the project node in the local repository hierarchy. It does not need to match the GitHub repository name, althought usually it is closely related.</p>

<p>The parent path must have at least one level, and generally defines the originator of the package (user or organization).</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;package name="parent/string"&gt;
  ...
&lt;/package&gt;
</code></pre>

<p>The JSON Syntax (string):</p>

<pre>
<code>"name": "string"
</code></pre>

<h3 id="description">
<code>description</code>
</h3>

<p>A paragraph with a reasonably detailed description of the package.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;description&gt;long string&lt;/description&gt;
</code></pre>

<p>The JSON Syntax (string):</p>

<pre>
<code>"description": "long string"
</code></pre>

<p>Example:</p>

<pre>
<code>&lt;package name="/ilg/STM32/F4/HAL"&gt;
  &lt;description&gt;The STM32F4 HAL library.&lt;/description&gt;
&lt;/package&gt;
</code></pre>

<h3 id="releases">
<code>releases</code>
</h3>

<p>The list, in reverse order, of all versions of the package publicly released.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;releases&gt;
  &lt;release name="semver"&gt;
    &lt;description&gt;long string&lt;/description&gt;
    &lt;date&gt;iso-date&lt;/date&gt;
    &lt;properties&gt;
      &lt;property name="string"&gt;value&lt;/string&gt;
      ...
    &lt;/properties&gt;
  &lt;/release&gt;
&lt;/releases&gt;
</code></pre>

<p>The JSON syntax (array of objects):</p>

<pre>
<code>"releases": [
  {
    "name": "semver",
    "description": "long string",
    "date": "iso-date",
    "property1": "value1",
    "property2": "value2",
    ...
  }
]
</code></pre>

<h3 id="keywords">
<code>keywords</code>
</h3>

<p>An array of strings, intended to help searches identify a package.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;keywords&gt;
  &lt;keyword&gt;string1&lt;/keyword&gt;
  &lt;keyword&gt;string2&lt;/keyword&gt;
  ...
&lt;/keywords&gt;
</code></pre>

<p>The JSON syntax (array of strings):</p>

<pre>
<code>"keywords": [
  "string1",
  "string2",
  ...
]
</code></pre>

<h3 id="homepage">
<code>homepage</code>
</h3>

<p>The full URL to the project home page, either a separate web or a GitHub/SourceForge/etc project page.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;homepage&gt;url&lt;/homepage&gt;
</code></pre>

<p>The JSON syntax (string):</p>

<pre>
<code>"homepage": "url"
</code></pre>

<h3 id="bugs">
<code>bugs</code>
</h3>

<p>The full URL to the project’s issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;bugs&gt;
  &lt;url&gt;string&lt;/url&gt;
  &lt;email&gt;string&lt;/email&gt;
&lt;/bugs&gt;
</code></pre>

<p>The JSON syntax (object):</p>

<pre>
<code>"bugs": {
  "url": "string",
  "email": "string"
}
</code></pre>

<p>Example:</p>

<pre>
<code>&lt;bugs&gt;
  &lt;url&gt;https://github.com/gnuarmeclipse/plug-ins/issues/1&lt;/url&gt;
&lt;/bugs&gt;
</code></pre>

<h3 id="license">
<code>license</code>
</h3>

<p>A string identifying the license for the package, so that people know how they are permitted to use it.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;license&gt;string&lt;/license&gt;
</code></pre>

<p>The JSON syntax (string):</p>

<pre>
<code>"license": "string"
</code></pre>

<p>The license is identified by a short ID, selected from the list of <a href="https://spdx.org/licenses/">SPDX license IDs</a>, ideally one that is <a href="http://opensource.org/licenses/alphabetical">OSI</a> approved.</p>

<p>If the package is licensed under multiple common licenses, use an <a href="http://npmjs.com/package/spdx">SPDX license expression syntax version 2.0</a> string, like this:</p>

<pre>
<code>&lt;license&gt;(ISC OR GPL-3.0)&lt;/license&gt;
</code></pre>

<p>If the license hasn’t been assigned an SPDX identifier, or if it is a custom license, use the following valid SPDX expression:</p>

<pre>
<code>&lt;license&gt;SEE LICENSE IN filename&lt;/license&gt;
</code></pre>

<p>Then include a file named <code>filename</code> at the top level of the package.</p>

<p>Finally, if you do not wish to grant others the right to use a private or unpublished package under any terms, use:</p>

<pre>
<code>&lt;license&gt;UNLICENSED&lt;/license&gt;
</code></pre>

<h3 id="maintainers">
<code>maintainers</code>
</h3>

<p>The maintainers are the persons who maintain the package (may be different from the persons who created the source files packaged in the package). The first maintainer is the person who created the package. The array extends at the end.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;maintainers&gt;
  &lt;maintainer name="string"&gt;
    &lt;email&gt;string&lt;/string&gt;
    &lt;url&gt;string&lt;/url&gt;
  &lt;/maintainer&gt;
&lt;/maintainers&gt;
</code></pre>

<p>The JSON syntax (array of objects):</p>

<pre>
<code>"maintainers": [
  {
    "name": "string",
    "email": "string",
    "url": "string"
  }
]
</code></pre>

<h3 id="contributors">
<code>contributors</code>
</h3>

<p>The contributors are the persons who contributed to the content of the package. The first contributor is the person who created the source files available in the package. The array extends at the end.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;contributors&gt;
  &lt;contributor name="string"&gt;
    &lt;email&gt;string&lt;/string&gt;
    &lt;url&gt;string&lt;/url&gt;
  &lt;/contributor&gt;
  ...
&lt;/contributors&gt;
</code></pre>

<p>The JSON syntax (array of objects):</p>

<pre>
<code>"contributors": [
  {
    "name": "string",
    "email": "string",
    "url": "string"
  }
]
</code></pre>

<h3 id="repository">
<code>repository</code>
</h3>

<p>The place where the pacakge repository is located. This is helpful for people who want to contribute.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;repository&gt;
  &lt;type&gt;string&lt;/type&gt;
  &lt;url&gt;string&lt;/url&gt;
&lt;/repository&gt;
</code></pre>

<p>The JSON syntax (array of objects):</p>

<pre>
<code>"repository": {
  "type": "string",
  "url": "string"
}
</code></pre>

<p>Support for the <code>git</code> type string is mandatory. Other types, like <code>svn</code>, might be added.</p>

<p>Example:</p>

<pre>
<code>&lt;repository&gt;
  &lt;type&gt;git&lt;/type&gt;
  &lt;url&gt;https://github.com/xpacks/arm-cmsis-core.git&lt;/url&gt;
&lt;/repository&gt;
</code></pre>

<h3 id="dependencies">
<code>dependencies</code>
</h3>

<p>Dependencies are specified in a simple object that maps a package name to a version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.</p>

<p>The XML syntax:</p>

<pre>
<code>&lt;dependencies&gt;
  &lt;package name="string"&gt;
    &lt;version&gt;string&lt;/version&gt;
  &lt;/package&gt;
&lt;/dependencies&gt;
</code></pre>

<p>The JSON syntax (object):</p>

<pre>
<code>"dependencies": {
  "string": "string",
  ...
}
</code></pre>

<p>The syntax for the version string is based on <a href="http://semver.org/">semver</a>, with the following expressions (inspired from NPM):</p>

<ul>
  <li><code>version</code> Must match version exactly</li>
  <li><code>&gt;version</code> Must be greater than version</li>
  <li><code>&gt;=version</code> etc</li>
  <li><code>&lt;version</code></li>
  <li><code>&lt;=version</code></li>
  <li><code>~version</code> “Approximately equivalent to version” See semver(7)</li>
  <li><code>^version</code> “Compatible with version” See semver(7)</li>
  <li><code>1.2.x</code> 1.2.0, 1.2.1, etc., but not 1.3.0</li>
  <li><code>*</code> Matches any version</li>
  <li><code>""</code> (just an empty string) Same as *</li>
  <li><code>version1 - version2</code> Same as &gt;=version1 &lt;=version2</li>
  <li><code>range1 || range2</code> Passes if either range1 or range2 are satisfied.</li>
</ul>

<p>Future versions may also support:</p>

<ul>
  <li>http://…/file.tgz</li>
  <li>git://…</li>
  <li>github://user/repo</li>
  <li>tag</li>
  <li>path/path/path (???)</li>
</ul>

<p>Example:</p>

<pre>
<code>&lt;package name="/ilg/stm32/f4/cmsis"&gt;
  ...
  &lt;dependencies&gt;
    &lt;package name="arm/cmsis"&gt;
      &lt;version&gt;&amp;gt;=4.4.0&lt;/version&gt;
    &lt;/package&gt;
  &lt;/dependencies&gt;
  ...
&lt;/package&gt;
</code></pre>

<hr />

<p>(This part is not updated yet)</p>

<h2 id="build">Build</h2>

<h3 id="build-artefact-types">Build artefact types</h3>

<p>The whole purpose of the XCDL components is to be used as reusable building blocks when creating standard artefacts like libraries and executables. It should be possible to create an executable from multiple libraries, each built from separate XCDL components.</p>

<p>The main development environment targeted by XCDL is Eclipse, so it should support the creation and management of CDT projects. As such, the definitions of the XCDL components should provide all information required by Eclipse CDT. Since XCDL is a superset of CMSIS Pack, it should be perfectly possible for the Eclipse projects to use/refer definitions provided by CMSIS Pack packages, like the list of devices/boards and their specific hardware details.</p>

<p>As a alternate to Eclipse, it should be possible to create XCDL projects entirely using command line tools.</p>

<h3 id="outline-of-the-new-project-process">Outline of the new project process</h3>

<p>Creating new projects generally starts with the target selection, usually a board. The board refer to the device, which refers to the core, so most details required by the Eclipse cross build plug-in can be set automatically.</p>

<p>The alternate, for cases when a board definition is not available, is to select the device from the list of known devices, known from the CMSIS Packs definitions.</p>

<p>The next step is to select a template, which will later simplify the individual component selection.</p>

<p>The <em>New C/C++ Project</em> wizard should not directly go to configuring the components, but create a project with the default setting, and then open the separate configuration editor.</p>

<p>This separate editor should be available at any time during the lifespan of the project, and can be invoked, for example, by editing the .xcdlconfig.xml file, and/or by using custom menu entries.</p>

<h3 id="outline-of-the-build-process">Outline of the build process</h3>

<p>The full build process is moulded after the Eclipse CDT build system. It is described in <a href="/The_build_process" title="wikilink">The build process</a>, but a summary is appropriate here. A build involves several directory structures:</p>

<ol>
  <li>The component repository. This is where all the package source code is held, along with XCDL files, documentation, and so on. For build purposes a component repository is read-only. Application developers will only modify the component repository when installing or removing packages, via the administration tool. Component writers will typically work with Git/local component repositories, which are read/write.</li>
  <li>The local source tree. This is where artefact specific files are located. For Eclipse projects, this is the project folder. The artefacts are built using the source files in this tree and selected source files from the component repository. Upon user request, the component framework tools may copy files from the component repository to the local source tree. Several artefacts can be constructed from one local source tree, usually variants of the same configuration, like Debug/Release, but this is not restricted by the framework, with special care it might be possible to build artefacts for different boards from the same source tree. For a given local source tree there is a single .xcdlconfig.xml file, containing one XCDL configuration for each artefact to be build.</li>
  <li>The build tree. Each configuration has its own build tree. For Eclipse projects, this is the output folder of each Eclipse build configuration. The build tree contains only intermediate files, object files and final artefact, list files, map files, etc. Once a build is complete, the build tree contains no information that is useful for application development and can be wiped, although this would slow down any rebuilds following changes to the configuration.</li>
  <li>An optional install tree, where the newly created artefacts are copied in a custom build step like <em>make install</em>. Eclipse projects do not use such a tree, but leave the artefacts to be used directly from the build tree.</li>
</ol>

<p>When used inside Eclipse, the build process involves the following steps:</p>

<ol>
  <li>Given a configuration, the component framework is responsible for updating the current project to match the definitions in the .xcdlconfig.xml. This extra step is implemented in a custom Eclipse builder, that requires, to be activated, a custom <em>nature</em> to be added to the project. The order of the builders associated to a project is significative, and the XCDL builder must be executed before the CDT builder. The usual case assumes that the actual source files are linked to those in the component repository. If, during the project creation, the user chose to keep local copies of the packs file, these are now copied locally.</li>
  <li>After the source files are linked and all required folders are created, the component framework generates the configuration headers, also in the specific build tree locations.</li>
  <li>The CDT builder is invoked and the library or executable artefact is created in the build tree.</li>
</ol>

<p>When invoked from a command line, the build process involves the following steps:</p>

<ol>
  <li>Given a configuration, the component framework is responsible for creating all the folders required during the build. If these folders already exist then the component framework is responsible for any clean-ups that may be necessary, for example if a package has been removed then all related files should be expunged from the build and install trees. The configuration header files will be generated at this time. Depending on the host environment, the component framework will also generate makefiles or some other way of building the various packages. Every time the configuration is modified this step needs to be repeated, to ensure that all option consequences take effect. Care is taken that this will not result in unnecessary rebuilds.</li>
  <li>The first step in an actual build is to make sure that the install tree contains all exported header files. All compilations will use the install tree’s include directory as one of the places to search for header files.</li>
  <li>All source files relevant to the current configuration get compiled. This involves a set of compiler flags initialized on a per-target basis, with each package being able to modify these flags, and with the ability for the user to override the flags as well. Care has to be taken here to avoid inappropriate target-dependencies in packages that are intended to be portable. The component framework has built-in knowledge of how to handle C, C++ and assembler source files. The <code>&lt;sourceFile&gt;</code> property is used to list the files that should get compiled. All object files end up in the build tree.</li>
  <li>The component framework provides support for custom build steps, using the make_object and make properties. The results of these custom build steps can either be object files that should end up in a library, or other files such as a linker script. It is possible to control the order in which these custom build steps take place, for example it is possible to run a particular build step before any of the compilations happen.</li>
</ol>

<h3 id="configurable-source-code">Configurable source code</h3>

<p>All packages should be totally portable to all target hardware (with the obvious exceptions of HAL and device driver packages). They should also be totally bug-free, require the absolute minimum amount of code and data space, be so efficient that cpu time usage is negligible, and provide lots of configuration options so that application developers have full control over the behavior. The configuration options are optional only if a package can meet the requirements of every potential application without any overheads. It is not the purpose of this guide to explain how to achieve all of these requirements.</p>

<p>The XCDL component framework does have some important implications for the source code: compiler flag dependencies; package interfaces vs. implementations; and how configuration options affect source code.</p>

<h4 id="compiler-flag-dependencies">Compiler flag dependencies</h4>

<p>Wherever possible component writers should avoid dependencies on particular compiler flags. Any such dependencies are likely to impact portability. For example, if one package needs to be built in big-endian mode and another package needs to be built in little-endian mode then usually it will not be possible for application developers to use both packages at the same time; in addition the application developer is no longer given a choice in the matter. It is far better for the package source code to adapt the endianness at compile-time, or possibly at run-time although that will involve code-size overheads.</p>

<h4 id="package-interfaces-and-implementations">Package interfaces and implementations</h4>

<p>The component framework provides encapsulation at the package level. A package <em>A</em> has no way of accessing the implementation details of another package <em>B</em> at compile-time. In particular, if there is a private header file somewhere in a package’s <em>src</em> sub-folder then this header file is completely invisible to other packages. Any attempts to cheat by using relative pathnames beginning with ../.. are generally doomed to failure because of the presence of package version directories. There are two ways in which one package can affect another: by means of the exported header files, which define a public interface; or via the XCDL scripts.</p>

<p>This encapsulation is a deliberate aspect of the overall XCDL component framework design. In most cases it does not cause any problems for component writers. In some cases enforcing a clean separation between interface and implementation details can improve the code. Also it reduces problems when a package gets upgraded: component writers are free to do pretty much anything on the implementation side, including renaming every single source file; care has to be taken only with the exported header files and with the XCDL data, because those have the potential of impacting other packages. Application code is similarly unable to access package implementation details, only the exported interface.</p>

<p>Very occasionally the inability of one package to see implementation details of another does cause problems. One example occurs in HAL packages, where it may be desirable for the architectural, variant and platform HAL’s to share some information that should not be visible to other packages or to application code. This may be addressed in the future by introducing the concept of friend packages, just as a C++ class can have friend functions and classes which are allowed special access to a class internals. It is not yet clear whether such cases are sufficiently frequent to warrant introducing such a facility.</p>

<h4 id="source-code-and-configuration-options">Source code and configuration options</h4>

<p>Configurability usually involves source code that needs to implement different behavior depending on the settings of configuration options. It is possible to write packages where the only consequence associated with various configuration options is to control what gets built, but this approach is limited and does not allow for fine-grained configurability. There are three main ways in which options could affect source code at build time:</p>

<ol>
  <li>
    <p>The component code can be passed through a suitable preprocessor, either an existing one such as m4 or a new one specially designed with configurability in mind. The original sources would reside in the component repository and the processed sources would reside in the build tree. These processed sources can then be compiled in the usual way.</p>

    <p>This approach has two main advantages. First, it is independent from the programming language used to code the components, provided reasonable precautions are taken to avoid syntax clashes between preprocessor statements and actual code. This would make it easier in future to support languages other than C and C++. Second, configurable code can make use of advanced preprocessing facilities such as loops and recursion.</p>

    <p>The disadvantage is that component writers would have to learn about a new preprocessor and embed appropriate directives in the code. This makes it much more difficult to turn existing code into components, and it involves extra training costs for the component writers. The extra definitions might also confuse document generating utlities like Doxygen.</p>
  </li>
  <li>
    <p>Compiler optimizations can be used to elide code that should not be present, for example:</p>

    <pre><code>...
if (OS_INTEGER_NUMBER_UARTS &gt; 0) {
  ...
}
...
</code></pre>

    <p>If the compiler knows that OS_INTEGER_NUMBER_UARTS is the constant number 0 then it is a trivial operation to get rid of the unnecessary code. The component framework still has to define this symbol in a way that is acceptable to the compiler, typically by using a const variable or a preprocessor symbol. In some respects this is a clean approach to configurability, but it has limitations:</p>

    <ul>
      <li>it cannot be used in the declarations of data structures or classes, nor does it provide control over entire functions</li>
      <li>in addition it may not be immediately obvious that this code is affected by configuration options, which may make it more difficult to understand</li>
      <li>even if the condition does not evaluate to true, and the optimiser gets rid of the code, it still requires the elided code to be syntactically correct, which sometimes it is not possible, due to missing references.</li>
    </ul>
  </li>
  <li>
    <p>Existing language preprocessors can be used. In the case of C or C++ this would be the standard C preprocessor, and configurable code would contain a number of <code>#ifdef</code> and <code>#if</code> statements.</p>

    <pre><code>#if defined(OS_DEBUG_INFRA_DEBUG_PRECONDITIONS)
  ...
#endif

...

#if (OS_INTEGER_NUMBER_UARTS &gt; 0)
  ...
#endif
</code></pre>

    <p>This approach has the advantage that the C preprocessor is a technology that is both well-understood and widely used. There are also disadvantages: the preprocessing facilities are rather limited; and some people (including ourselves) consider the technology to be ugly, generally decreasing program readability.</p>
  </li>
</ol>

<h4 id="preprocessor-definitions">Preprocessor definitions</h4>

<p>The current component framework generates configuration header files with C preprocessor <code>#define</code>s for each option (typically, there various properties which can be used to control this). It is up to component writers to decide whether to use preprocessor <code>#ifdef</code> statements or language constructs such as if. At present there is no support for languages which do not involve the C preprocessor.</p>

<h4 id="c11-constexpr">C++11 <strong>constexpr</strong></h4>

<p>The second type of definitions that the component framework should support are <em>C++11 constexpr</em> definitions. These definitions are the typed equivalent of the preprocessor definitions, but with some significant differences:</p>

<ul>
  <li>are processed by the compiler, not the preprocessor; this has the advantage of allowing type checks</li>
  <li>
    <p>can be grouped in name spaces; this minimise the risk of name clashes</p>

    <pre><code>namespace one
{
  constexpr int variable = 1234;
}
</code></pre>
  </li>
</ul>

<p>It is recommended to use constexpr expressions for all options providing values, and limit the use of preprocessor definitions only to control which parts of the code is included, i.e. definitions like <code>#if defined(OS_INCLUDE_SOME_FUNCTIONALITY)</code>.</p>

<p>TODO: add definitions to support constexpr to properties.</p>

<h3 id="exported-header-files">Exported header files</h3>

<p>A package’s exported header files should specify the interface provided by that package, and avoid any implementation details. However there may be performance or other reasons why implementation details occasionally need to be present in the exported headers.</p>

<p>Configurability has a number of effects on the way exported header files should be written. There may be configuration options which affect the interface of a package, not just the implementation. It is necessary to worry about nested <code>#include</code>’s and how this affects package and application builds. A special case of this relates to whether or not exported header files should <code>#include</code> configuration headers. These configuration headers are exported, but should only be <code>#include</code>’d when necessary.</p>

<h4 id="configurable-functionality">Configurable functionality</h4>

<p>Many configuration options affect only the implementation of a package, not the interface. However some options will affect the interface as well, which means that the options have to be tested in the exported header files. Some implementation choices, for example whether or not a particular function should be inlined, also need to be tested in the header file because of language limitations.</p>

<p>Consider a configuration option OS_INCLUDE_KERNEL_MUTEX_TIMEDLOCK which controls whether or not a function os_mutex_timedlock() is provided. The exported kernel header file <em>os/kernel/kapi.h</em> could contain the following:</p>

<pre>
<code>#include &lt;pkgconf/kernel.h&gt;
...
#ifdef OS_INCLUDE_KERNEL_MUTEX_TIMEDLOCK
extern bool os_mutex_timedlock(os_mutex_t*);
#endif
</code></pre>

<p>This is a correct header file, in that it defines the exact interface provided by the package at all times. However is has a number of implications. First, the header file is now dependent on pkgconf/kernel.h, so any changes to kernel configuration options will cause <em>os/kernel/kapi.h</em> to be out of date, and any source files that use the kernel interface will need rebuilding. This may affect sources in the kernel package, in other packages, and in application source code. Second, if the application makes use of this function somewhere but the application developer has misconfigured the system and disabled this functionality anyway then there will now be a compile-time error when building the application. Note that other packages should not be affected, since they should impose appropriate constraints on OS_INCLUDE_KERNEL_MUTEX_TIMEDLOCK if they use that functionality (although of course some dependencies like this may get missed by component developers).</p>

<p>An alternative approach would be:</p>

<pre>
<code>extern bool os_mutex_timedlock(os_mutex_t*);
</code></pre>

<p>Effectively the header file is now lying about the functionality provided by the package. The first result is that there is no longer a dependency on the kernel configuration header. The second result is that an application file using the timedlock function will now compile, but the application will fail to link. At this stage the application developer still has to intervene, change the configuration, and rebuild the system. However no application recompilations are necessary, just a relink.</p>

<p>Theoretically it would be possible for a tool to analyze linker errors and suggest possible configuration changes that would resolve the problem, reducing the burden on the application developer. No such tool is planned in the short term.</p>

<p>It is up to component writers to decide which of these two approaches should be preferred. Note that it is not always possible to avoid <code>#include</code>’ing a configuration header file in an exported one, for example an option may affect a data structure rather than just the presence or absence of a function. Issues like this will vary from package to package.</p>

<h4 id="nested-includes">Nested <code>#include</code>’s</h4>

<p>As a general rule, unnecessary <code>#include</code>’s should be avoided. A header file should <code>#include</code> only those header files which are absolutely needed for it to define its interface. Any additional <code>#include</code>’s make it more likely that package or application source files become dependent on configuration header files and will get rebuilt unnecessarily when there are minor configuration changes.</p>

<h4 id="including-configuration-headers">Including configuration headers</h4>

<p>Exported header files should avoid <code>#include</code>’ing configuration header files unless absolutely necessary, to avoid unnecessary rebuilding of both application code and other packages when there are minor configuration changes. A <code>#include</code> is needed only when a configuration option affects the exported interface, or when it affects some implementation details which is controlled by the header file such as whether or not a particular function gets inlined.</p>

<p>There are a couple of ways in which the problem of unnecessary rebuilding could be addressed. The first would require more intelligent handling of header file dependency handling by the tools (especially the compiler) and the build system. This would require changes to various non-XCDL tools. An alternative approach would be to support finer-grained configuration header files, for example there could be a file pkgconf/libc/inline.h controlling which functions should be inlined. This could be achieved by some fairly simple extensions to the component framework, but it makes it more difficult to get the package header files and source code correct: a C preprocessor <code>#ifdef</code> directive does not distinguish between a symbol not being defined because the option is disabled, or the symbol not being defined because the appropriate configuration header file has not been <code>#include</code>’d. It is likely that a cross-referencing tool would have to be developed first to catch problems like this, before the component framework could support finer-grained configuration headers.</p>

<h3 id="package-documentation">Package documentation</h3>

<p>On-line package documentation should be in HTML format. The component framework imposes no special limitations: component writers can decide which version of the HTML specification should be followed; they can also decide on how best to cope with the limitations of different browsers. In general it is a good idea to keep things simple.</p>

<h3 id="test-cases">Test cases</h3>

<p>Packages should normally come with one or more test cases. This allows application developers to verify that a given package works correctly on their particular hardware and in their particular configuration, making it slightly more likely that they will attempt to find bugs in their own code rather than automatically blaming the component writers.</p>

<h4 id="google-test">Google Test</h4>

<p>XCDL itself does not include a specific testing infrastructure and tests may use any C/C++ testing infrastructure.</p>

<p>µOS++ fully supports the <a href="http://code.google.com/p/googletest/">Google Test</a> &amp; <a href="http://code.google.com/p/googlemock/">Google Mock</a> testing infrastructure, and XCDL should be able to configure the environment required to run these tests.</p>

<h4 id="running-tests-on-the-host">Running tests on the host</h4>

<p>If possible, tests should be written highly portable, and should be able to run on the host, as command line applications returning a non-zero exit code if the test failed.</p>

<h4 id="continuous-integration">Continuous integration</h4>

<p>XCDL should provide support to collect information about all tests contributed by all packages available in a configuration and run all of them from a scriptable environment, in order to facilitate integration into continuous integration tools like <a href="http://en.wikipedia.org/wiki/Hudson_(software)">Hudson</a>.</p>

<h4 id="semihosted-tests">Semihosted tests</h4>

<p>XCDL should also provide support to run the same tests on the actual hardware (or on simulators like QEMU), using the semihosting infrastructure.</p>

<h4 id="todo-update-xcdl-tests-definitions">TODO: update XCDL tests definitions</h4>

<p>At the time of writing the application developer support for building and running test cases via the component framework is under review and likely to change. Currently each eCos test case should consist of a single C or C++ source file that can be compiled with the package’s set of compiler flags and linked like any application program. Each test case should use the testing API defined by the infrastructure. A magically-named calculated configuration option of the form <code>CYGPKG_&lt;PACKAGE-NAME&gt;_TESTS</code> lists the test cases.</p>

<h3 id="host-side-support">Host-side support</h3>

<p>On occasion it would be useful for an XCDL package to be shipped with host-side support. This could take the form of an additional tool needed to build that package. It could be an application intended to communicate with the target-side package code and display monitoring information. It could be a utility needed for running the package test cases, especially in the case of device drivers. The component framework does not yet provide any such support for host-side software, and there are obvious issues related to portability to the different machines that can be used for hosts. This issue may get addressed in some future release. In some cases custom build steps can be subverted to do things on the host side rather than the target side, but this is not recommended.</p>

<h2 id="making-a-package-distribution">Making a package distribution</h2>

<p>Developers of new XCDL packages are advised to distribute their packages in the form of XCDL package distribution files. Packages distributed in this format may be added to existing XCDL component repositories in a robust manner using the Package Administration Tool. This chapter describes the format of package distribution files and details how to prepare an eCos package for distribution in this format.</p>

<h3 id="the-xcdl-package-distribution-file-format">The XCDL package distribution file format</h3>

<p>XCDL package distribution files are zipped archives which contain both the source code for one or more XCDL packages and a data file containing package information to be added to the component repository content list. The distribution files are subject to the following rules:</p>

<p>TODO: update for XCDL, this currently refers to eCos</p>

<ol>
  <li>The data file must be named pkgadd.db and must be located in the root of the tar archive. It must contain data in a format suitable for appending to the eCos repository database (ecos.db). the Section called Updating the ecos.db database in Chapter 3 describes this data format. Note that a database consistency check is performed by the eCos Administration Tool when pkgadd.db has been appended to the database. Any new target entries which refer to unknown packages will be removed at this stage.</li>
  <li>The package source code must be placed in one or more $(package-path)/$(version) directories in the tar archive, where each $(package-path) directory path is specified as the directory attribute of one of the packages entries in pkgadd.db.</li>
  <li>An optional license agreement file named pkgadd.txt may be placed in the root of the tar archive. It should contain text with a maximum line length of 79 characters. If this file exists, the contents will be presented to the user during installation of the package. The eCos Package Administration Tool will then prompt the user with the question “Do you accept all the terms of the preceding license agreement?”. The user must respond “yes” to this prompt in order to proceed with the installation.</li>
  <li>Optional template files may be placed in one or more templates/$(template_name) directories in the tar archive. Note that such template files would be appropriate only where the packages to be distributed have a complex dependency relationship with other packages. Typically, a third party package can be simply added to an eCos configuration based on an existing core template and the provision of new templates would not be appropriate. the Section called Templates in Chapter 6 contains more information on templates.</li>
  <li>The distribution file must be given a .epk (not .tar.gz) file extension. The .epk file extension serves to distinguish eCos package distributions files from generic gzipped GNU tar archives. It also discourages users from attempting to extract the package from the archive manually. The file browsing dialog of the eCos Package Administration Tool lists only those files which have a .epk extension.</li>
  <li>No other files should be present in the archive.</li>
  <li>Files in the tar archive may use LF or CRLF line endings interchangably. The eCos Administration Tool ensures that the installed files are given the appropriate host-specific line endings.</li>
  <li>Binary files may be placed in the archive, but the distribution of object code is not recommended. All binary files must be given a .bin suffix in addition to any file extension they may already have. For example, the GIF image file myfile.gif must be named myfile.gif.bin in the archive. The .bin suffix is removed during file extraction and is used to inhibit the manipulation of line endings by the eCos Administration Tool.</li>
</ol>

<h3 id="preparing-xcdl-packages-for-distribution">Preparing XCDL packages for distribution</h3>

<p>TODO: define the procedure to pack the content of a package folder to an archive.</p>

<h2 id="credits">Credits</h2>

<p>The initial content of this page was based on <em>Chapter 2. Package Organization</em> of <em>The eCos Component Writer’s Guide</em>, by Bart Veer and John Dallaway, published in 2001.</p>








<ul class="share-buttons">
  <li><div class="fb-share-button" data-href="http://ilg-ul.github.io/guide/packages/" data-layout="button"></div></li>
  <li><div class="tw-share-button"><a href="https://twitter.com/share" class="twitter-share-button" data-count="none">Tweet</a></div></li>
</ul>



      </div>

    </div>
  </div>

</div>

<div class="container">

  <div class="site-footer">
  <div class="site-footer-links left">
    <ul>
  <li>© 2015 Liviu Ionescu</li>
  <li>Hosted on GitHub</li>
  <li><a href="/feed.xml"><img src="/assets/images/feed-20.png" alt="RSS" /></a></li>
</ul>


  </div>
  <a href="https://github.com/xcdl/xcdl-go" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
  </a>
  <div class="site-footer-links right">
    <ul>
  <li><a href="/">Home</a></li>
  <li><a href="/blog/">News</a></li>
  <li><a href="https://github.com/xcdl/xcdl-go/releases">Releases</a></li>
  <li><a href="https://github.com/xcdl/xcdl-go/issues">Support</a></li>
  <li><a href="/about/">About</a></li>
</ul>

  </div>
</div>


</div>

</body>
</html>
