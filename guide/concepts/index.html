<!doctype html>
<html>

<head>

  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>XCDL concepts and rationals</title>
  <meta name="description" content="The eXtensible Component Definition Language component framework">

  <meta property="og:title" content="XCDL concepts and rationals" />
  <meta property="og:site_name" content="XCDL / xPack" />

  <link rel="alternate" type="application/rss+xml" title="XCDL / xPack" href="/feed.xml" />








  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css?201510121951" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/print.css?201510121951" media="print">

  <link rel="canonical" href="http://ilg-ul.github.io/guide/concepts/">



  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-16767008-13', 'auto');
  ga('send', 'pageview');

</script>



</head>


<body>

<div class="container">

  <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

  <div class="site-header">
  <img class="site-icon" src="/assets/icons/components.png" height="100" width="100">
  <div class="site-title">
    <h1><a href="/">XCDL / xPack</a></h1>
    <p>The eXtensible Component Definition Language component framework</p>
  </div>
</div>


</div>

<div class="container">

  <div class="wrapper">
    <div class="site-body">

      <div class="site-sidebar">


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="newsblog"><a href="/blog/">News</a></h4>

<ul>
  <li><a href="/blog/2015/10/12/github-pages/">The GitHub Wiki content was migrated to GitHub Pages</a></li>
  <li><a href="/blog/2015/09/26/github-wiki/">The XCDL Wiki content was migrated from MediaWiki to GitHub Wiki</a></li>
</ul>


    </div>
  </div>


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="home"><a href="/">Home</a></h4>

<h4 id="component-writers-guide">Component Writer’s Guide</h4>
<ul>
  <li><a href="/guide/concepts/">Concepts and rationals</a></li>
  <li><a href="/guide/packages/">Packages</a></li>
  <li><a href="/guide/repositories/">Repositories</a></li>
  <li><a href="/guide/metadata/">Metadata</a></li>
  <li><a href="/guide/build-process/">The build process</a></li>
</ul>

<h4 id="reference">Reference</h4>
<ul>
  <li><a href="/reference/metadata/">Metadata</a></li>
</ul>

<h4 id="license">License</h4>

<ul>
  <li><a href="https://www.gnu.org/licenses/gpl.html">GPL</a></li>
</ul>

<h4 id="aboutabout"><a href="/about/">About</a></h4>

    </div>
  </div>

  <div class="site-theme">
    This site uses the <a href="https://github.com/ilg-ul/github-jekyll-theme">GitHub Wiki-like</a> theme by <a href="https://github.com/ilg-ul">Liviu Ionescu</a>.
  </div>

</div>


      <div class="site-content">

        
<h1 class="page-title">XCDL concepts and rationals</h1>
<p class="last-modified">Last modified on Sun Nov 15 10:47:04 2015 UTC.</p>


<div id="toc-container">
<table class="toc" id="toc">
<tbody>
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toc_level-1 toc_section-1">
<a href="#why-xcdl-for-the-impacient"><span class="tocnumber">1</span> <span class="toctext">Why XCDL? (for the impacient)</span></a>
<ul>
<li class="toc_level-2 toc_section-2">
<a href="#the-very-short-answer"><span class="tocnumber">1.1</span> <span class="toctext">The very short answer</span></a>
</li>
<li class="toc_level-2 toc_section-3">
<a href="#rationals"><span class="tocnumber">1.2</span> <span class="toctext">Rationals</span></a>
</li>
<li class="toc_level-2 toc_section-4">
<a href="#proposal"><span class="tocnumber">1.3</span> <span class="toctext">Proposal</span></a>
</li>
<li class="toc_level-2 toc_section-5">
<a href="#compliance-levels"><span class="tocnumber">1.4</span> <span class="toctext">Compliance levels</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-6">
<a href="#why-xcdl-the-long-version"><span class="tocnumber">2</span> <span class="toctext">Why XCDL? (the long version)</span></a>
<ul>
<li class="toc_level-2 toc_section-7">
<a href="#multi-variant"><span class="tocnumber">2.1</span> <span class="toctext">Multi-variant</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-8">
<a href="#why-manage-dependencies"><span class="tocnumber">3</span> <span class="toctext">Why manage dependencies?</span></a>
</li>
<li class="toc_level-1 toc_section-9">
<a href="#why-configurability"><span class="tocnumber">4</span> <span class="toctext">Why configurability?</span></a>
<ul>
<li class="toc_level-2 toc_section-10">
<a href="#reusability"><span class="tocnumber">4.1</span> <span class="toctext">Reusability</span></a>
</li>
<li class="toc_level-2 toc_section-11">
<a href="#memory-constraints"><span class="tocnumber">4.2</span> <span class="toctext">Memory constraints</span></a>
</li>
<li class="toc_level-2 toc_section-12">
<a href="#debugging"><span class="tocnumber">4.3</span> <span class="toctext">Debugging</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-13">
<a href="#approaches-to-configurability"><span class="tocnumber">5</span> <span class="toctext">Approaches to configurability</span></a>
<ul>
<li class="toc_level-2 toc_section-14">
<a href="#run-time"><span class="tocnumber">5.1</span> <span class="toctext">Run-time</span></a>
</li>
<li class="toc_level-2 toc_section-15">
<a href="#link-time"><span class="tocnumber">5.2</span> <span class="toctext">Link-time</span></a>
</li>
<li class="toc_level-2 toc_section-16">
<a href="#compile-time"><span class="tocnumber">5.3</span> <span class="toctext">Compile-time</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-17">
<a href="#terminology"><span class="tocnumber">6</span> <span class="toctext">Terminology</span></a>
<ul>
<li class="toc_level-2 toc_section-18">
<a href="#metadata"><span class="tocnumber">6.1</span> <span class="toctext">Metadata</span></a>
</li>
<li class="toc_level-2 toc_section-19">
<a href="#components"><span class="tocnumber">6.2</span> <span class="toctext">Components</span></a>
</li>
<li class="toc_level-2 toc_section-20">
<a href="#component-framework"><span class="tocnumber">6.3</span> <span class="toctext">Component framework</span></a>
</li>
<li class="toc_level-2 toc_section-21">
<a href="#packages"><span class="tocnumber">6.4</span> <span class="toctext">Packages</span></a>
</li>
<li class="toc_level-2 toc_section-22">
<a href="#component-repositories"><span class="tocnumber">6.5</span> <span class="toctext">Component repositories</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-23">
<a href="#xcdl-metadata"><span class="tocnumber">7</span> <span class="toctext">XCDL metadata</span></a>
<ul>
<li class="toc_level-2 toc_section-24">
<a href="#xcdl-objects"><span class="tocnumber">7.1</span> <span class="toctext">XCDL objects</span></a>
</li>
<li class="toc_level-2 toc_section-25">
<a href="#the-virtual-hierarchy"><span class="tocnumber">7.2</span> <span class="toctext">The virtual hierarchy</span></a>
</li>
<li class="toc_level-2 toc_section-26">
<a href="#options"><span class="tocnumber">7.3</span> <span class="toctext">Options</span></a>
</li>
<li class="toc_level-2 toc_section-27">
<a href="#components-1"><span class="tocnumber">7.4</span> <span class="toctext">Components</span></a>
</li>
<li class="toc_level-2 toc_section-28">
<a href="#files"><span class="tocnumber">7.5</span> <span class="toctext">Files</span></a>
</li>
<li class="toc_level-2 toc_section-29">
<a href="#packages-1"><span class="tocnumber">7.6</span> <span class="toctext">Packages</span></a>
</li>
<li class="toc_level-2 toc_section-30">
<a href="#configurations"><span class="tocnumber">7.7</span> <span class="toctext">Configurations</span></a>
</li>
<li class="toc_level-2 toc_section-31">
<a href="#targets"><span class="tocnumber">7.8</span> <span class="toctext">Targets</span></a>
</li>
<li class="toc_level-2 toc_section-32">
<a href="#templates"><span class="tocnumber">7.9</span> <span class="toctext">Templates</span></a>
</li>
<li class="toc_level-2 toc_section-33">
<a href="#properties"><span class="tocnumber">7.10</span> <span class="toctext">Properties</span></a>
</li>
<li class="toc_level-2 toc_section-34">
<a href="#consequences"><span class="tocnumber">7.11</span> <span class="toctext">Consequences</span></a>
</li>
<li class="toc_level-2 toc_section-35">
<a href="#constraints"><span class="tocnumber">7.12</span> <span class="toctext">Constraints</span></a>
</li>
<li class="toc_level-2 toc_section-36">
<a href="#conflicts"><span class="tocnumber">7.13</span> <span class="toctext">Conflicts</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-37">
<a href="#credits"><span class="tocnumber">8</span> <span class="toctext">Credits</span></a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div><h2 id="why-xcdl-for-the-impacient">Why XCDL? (for the impacient)</h2>

<h3 id="the-very-short-answer">The very short answer</h3>

<p>Well, if children can build complex toys from LEGO bricks, why couldn’t we build software from components in a similar way?</p>

<h3 id="rationals">Rationals</h3>

<p>XCDL was designed beacause:</p>

<ul>
  <li>
    <p>for better performance (size, optimisation, etc) libraries are not the solution, and compile time configuration is preferred;</p>
  </li>
  <li>
    <p>it is crazy that although the software author knows very well</p>

    <ul>
      <li>where the source folders are,</li>
      <li>where the include folders are,</li>
      <li>which are the custom compile options,</li>
    </ul>

    <p>most of the time users still need to enter these setting manually in their development tools, each time they create a new project that uses that piece of software.</p>
  </li>
</ul>

<h3 id="proposal">Proposal</h3>

<p>Why not pack together the actual source code with some simple and portable metadata, to automate the project creation, ease further updates and generally help automate project management?</p>

<h3 id="compliance-levels">Compliance levels</h3>

<p>There may be multiple compliance levels, from simple to complex, each adding more metadata for supporting more functionality:</p>

<ol>
  <li>add metadata to tell what other packages are required, which are the source folders, the include folders, and the custom compile options;</li>
  <li>add metadata to group source files in related components, structured in a virtual hierarchy, with dependencies and conditions when these components are active/enabled;</li>
  <li>add metadata to define configuration options, also to be shown as nodes in the virtual hierarchy, with dependencies and formulas to compute option values with knowledge about the entire build environment</li>
  <li>add metadata and templates to dynamically generate source files with content adapted to various configuration selections adn options.</li>
  <li>possibly more!</li>
</ol>

<h2 id="why-xcdl-the-long-version">Why XCDL? (the long version)</h2>

<p>As the complexity of embedded system grows, it is more and more difficult to manage the complexity of putting together multiple components with lots of dependencies and configuration options.</p>

<p>To address this problem, XCDL defines and implements a component framework, as a set of metadata and a collection of tools specifically designed to support <strong>multi-variant cross-building embedded system images</strong> based on reusable components. This component framework is extensible, allowing additional components to be added to the build system at any time.</p>

<p>Although designed to meed the requirements of building embedded applications, XCDL should be generic enough to be used to build regular applications/libraries too.</p>

<h3 id="multi-variant">Multi-variant</h3>

<p>In the XCDL context, <em>multi-variant</em> covers the following:</p>

<ul>
  <li>multiple processor architectures (like ARM Cortex-M), with multiple sub-architectures (like M3, M4, M0), multiple manufacturer families (like STM32F1, STM32F4), multiple sub-families (like STM32F10x Connectivity Line) and multiple devices (like ST STM32F107VG);</li>
  <li>as an extension to architectures, synthetic architectures, like POSIX, can also be considered targets, mainly used to run test cases;</li>
  <li>multiple hardware platforms (boards, board revisions);</li>
  <li>multiple synthetic run POSIX platforms (like OS X, GNU/Linux, MSYS2 under Windows);</li>
  <li>multiple toolchains (like GCC, LLVM clang)</li>
  <li>multiple build platforms (like OS X, GNU/Linux, Windows)</li>
</ul>

<h2 id="why-manage-dependencies">Why manage dependencies?</h2>

<p>Automatic dependencies management is the first and foremost feature of the XCDL component framework.</p>

<p>Properly defined components, with accurate dependencies, allow to automatically create projects with all required source files and headers, and with all required compile and link options properly set. For example if a configuration refers to the STM32F4-DISCOVERY board, this will refer to the STM32F407VG processor, which will refer to the STM32F4 startup code, which will refer to the CMSIS CORE headers, so all required pieces will fit together without user intervention.</p>

<h2 id="why-configurability">Why configurability?</h2>

<p>The XCDL component framework places a great deal of emphasis on configurability.</p>

<h3 id="reusability">Reusability</h3>

<p>The fundamental goal is to allow large parts of embedded applications to be constructed from generic reusable software components, which need to be adjusted to fit together and to meet existing constraints.</p>

<h3 id="memory-constraints">Memory constraints</h3>

<p>Many embedded applications have to work with limited memory, to keep down manufacturing costs. The component framework must allow users to configure the components so that any unnecessary functionality gets removed, for RAM (and sometimes Flash) usage to be kept to a minimum.</p>

<h3 id="debugging">Debugging</h3>

<p>Embedded systems tend to be difficult to debug. The reusable components can provide debugging assistance in various ways. Allowing users to control which debugging features are enabled for any given application build is very desirable.</p>

<h2 id="approaches-to-configurability">Approaches to configurability</h2>

<p>The purpose of configurability is to control the behaviour of components and the relationships between components. The component writer includes as many different behaviours as possible, but has no way of knowing in advance exactly how a particular component will end up being used. When an application uses a component there must be some way of specifying the desired behaviour.</p>

<h3 id="run-time">Run-time</h3>

<p>One way to control the behaviour is at <strong>run time</strong>. There is of course a major disadvantage in terms of the size of the final application image: the code that gets linked with the application has to provide support for all possible behaviour cases, even if the application does not require it.</p>

<h3 id="link-time">Link-time</h3>

<p>Another approach is to control the behaviour at <strong>link time</strong>, typically by using inheritance in an object-oriented language and linking only one instance of the implementation.</p>

<h3 id="compile-time">Compile-time</h3>

<p>The XCDL component framework allows the behaviour of components to be controlled at an even earlier time: when the component source code gets compiled.</p>

<p>In theory, <strong>compile-time</strong> configurability should give the best possible results in terms of code size, because it allows code to be controlled at the individual statement level rather than at the function or object level. <strong>The overall result is that the final application image contains only the code and data that is really needed for the application to work, and nothing else</strong>.</p>

<p>Compile-time configurability is not intended to replace the other approaches but rather to complement them.</p>

<p>There will be times when run-time selection of behaviour is desirable: for example an application may need to be able to change the baud rate of a serial line, and the system must then provide a way of doing this at run-time. There will also be times when link-time selection is desirable.</p>

<h2 id="terminology">Terminology</h2>

<p>The XCDL component architecture involves a number of key concepts, presented below.</p>

<h3 id="metadata">Metadata</h3>

<p>In the context of XCDL, metadata (generally defined as <em>data about data</em>) is additional data about the software project, to define build settings, dependencies, options, etc. Metadata is stored in various separate files, usually with names starting with dots, like <code>.xcdl.json</code>.</p>

<h3 id="components">Components</h3>

<p>A <strong>component</strong> is a generic unit of functionality, usually containing a number of related files and configuration data. More details in the Components sub-section below.</p>

<h3 id="component-framework">Component framework</h3>

<p>The expression <strong>component framework</strong> is used to describe the collection of tools that allow software developers to manage a collection of components (usually organised in one or more component repositories) and to configure a build system to use these components.</p>

<h3 id="packages">Packages</h3>

<p>A <strong>package</strong> is the unit of distribution of components. It includes one or more related components.</p>

<p>A typical package contains the following:</p>

<ul>
  <li>some number of source files which will end up compiled in the project; some files may serve other purposes, for example to provide a linker script;</li>
  <li>exported header files which define the interface provided by the package;</li>
  <li>on-line documentation, for example reference pages for each exported function;</li>
  <li>some number of test cases, shipped in source format, allowing users to check that the package is working as expected on their particular hardware and in their specific configuration;</li>
  <li>one or more XCDL metadata files describing the package to the component framework.</li>
</ul>

<p>Not all packages need to contain all of these. For example some packages such as device drivers may not provide a new interface, instead they just provide another implementation of an existing interface. However <strong>all packages must contain at least one metadata file</strong> that describes the package to the component framework (a <code>.pdsc</code> file for CMSIS packages or a <code>.xpackage.json</code> and several <code>.xcdl.json</code> files for XCDL/xPack packages).</p>

<p>It is possible to create a binary distribution file for a package containing all of the source code, header files, documentation, and other relevant files.</p>

<p>More details in the Packages section below and in the separate <a href="/guide/packages/">XCDL Packages</a> section.</p>

<h4 id="portability">Portability</h4>

<p>Portability is a mandatory requirement, all XCDL tools must be able to run on all primary desktop environments, like Windows, OS X and GNU/Linux.</p>

<h4 id="reference-implementation">Reference implementation</h4>

<p>The reference implementation will include one or more Eclipse plug-ins as graphical configuration tools, and one or more command line tools for non graphical environments.</p>

<h3 id="component-repositories">Component repositories</h3>

<p>Generally a <strong>component repository</strong> is a managed collection of packages. To reduce complexity, packages of different types (CMSIS vs XCLD/xPack) will be grouped in different repositories.</p>

<p>The component framework must be able to manage multiple component repositories, of different types, at a time.</p>

<p>Physically a component repository is a hierarchy of folders, with folders usually directly mapping the hierarchy of packages.</p>

<p>The component framework includes tools that allows new packages or new versions of a package to be installed, old packages to be removed, and so on. The component repository includes special files, maintained by the administration tool, which contain details of the various registered packages.</p>

<h4 id="read-only">Read-only</h4>

<p>To preserve components integrity, the component repository is treated as a read-only resource that can be shared by multiple projects and multiple users. Application developers are not allowed to modify anything inside the component repository and build tools should involve separate build and install trees.</p>

<p>Usually application developers install packages by unpacking binary archives, downloaded from http/ftp servers.</p>

<h4 id="read-write">Read-write</h4>

<p>However, component writers need to modify files directly in the component repository. To simplify the development, the component framework should directly accept to register local folder structures, containing the source code and metadata used to build the packages.</p>

<p>Usually component writers install packages by cloning one or more Git repositories (one main repository with multiple submodules linked to it, one for each package).</p>

<h2 id="xcdl-metadata">XCDL metadata</h2>

<p>The configuration tools require information about the various options provided by each package, their consequences and constraints, and other properties such as the location of online documentation. This information has to be provided in the form of <strong>XCDL</strong> metadata files. XCDL is short for <strong>eXtensible Component Definition Language</strong>, and is specifically designed as a way of describing configuration options.</p>

<h3 id="xcdl-objects">XCDL objects</h3>

<p>The XCDL definition language includes several objects used to define all the configuration details.</p>

<p>The XCDL objects are organised hierarchically, from leaf option objects up to the root repository object.</p>

<h3 id="the-virtual-hierarchy">The virtual hierarchy</h3>

<p>In addition to the physical view represented by the file system folders and files, the XCDL hierarchy can be considered a virtual view of the project resources.</p>

<p>In Eclipse, this virtual hierarchy can be presented in a custom project explorer. Inactive nodes will not be shown in the virtual hierarchy at all.</p>

<h4 id="javascript-mapping">JavaScript mapping</h4>

<p>As a design decision, the XCDL objects must map 1:1 to JavaScript objects, i.e. have properties whose names match the JavaScript naming convention and have only values of type string, number, object or array of objects (not necessarily of same type).</p>

<p>The main advantage of defining the XCDL objects using the JavaScript syntax (compared, for instance with XML definitions) is an inherent simplicity and uniformity. As a consequence, XCDL objects can be very easily serialised in JSON files, the preferred exchange format.</p>

<h4 id="hierarchy">Hierarchy</h4>

<p>Except the root node, all XCDL objects have a single parent; in other words the nodes can be represented as a tree.</p>

<p>Except leaf nodes, all XCDL objects also have an ordered array of children nodes.</p>

<h4 id="node-name">Node name</h4>

<p>Each node has a property called <code>name</code>. Names are short strings, and must follow the following rules:</p>

<ul>
  <li>be unique for a given parent</li>
  <li>be accepted as POSIX file/folder name; this means letters, figures, and very few special characters, like <code>[-_.]</code>; for multi-word names, <code>-</code> (dash) is the preferred separator; <code>.</code> is used in version names.</li>
</ul>

<p>Using the JavaScript syntax, the node names are strings, defined with the <code>name</code> property.</p>

<pre>
<code>{
  name: 'RCC',
  ...
}
</code></pre>

<p>When used to decorate a GUI, the node name is the string permanently displayed to identify the node.</p>

<h4 id="node-type">Node type</h4>

<p>Each node must have a string property called <code>type</code>.</p>

<p>The node type defines the acceptable properties and children.</p>

<p>Some node types, like <code>file</code>, require a second property <code>subType</code> to fully identify the node.</p>

<p>When used to decorate a GUI, the node type defines the icon associated with the node.</p>

<h4 id="node-description">Node description</h4>

<p>Each node must have a string property called <code>description</code>. Descriptions are reasonable long strings.</p>

<pre>
<code>{
  name: 'RCC',
  type: 'component',
  description: 'Real-Time Clock Control',
  ...
}
</code></pre>

<p>When used to decorate a GUI, the node description is generally shwown as a tooltip, activated when the mouse hovers over the node, or in additional views showing all node details.</p>

<h4 id="node-children">Node children</h4>

<p>If a node has children, they are grouped as an array of objects.</p>

<pre>
<code>{
  name: 'HAL',
  type: 'component',
  ...
  nodes: [
    {
      name: 'RCC',
      type: 'component',
      ...
    }
  ]
}
</code></pre>

<h4 id="xcdl-paths">XCDL paths</h4>

<p>Similar to files in a filesystem, XCDL nodes can be addressed as a sequence of slash separated node names:</p>

<pre>
<code>/ilg/STM32/STM32F4/HAL/RCC
</code></pre>

<p>Addressing nodes can be done with:</p>

<ul>
  <li>complete paths, if they start with <code>/</code>; they are similar to absolute file system paths;</li>
  <li>incomplete paths, if they do not start with <code>/</code></li>
</ul>

<p>Incomplete paths are searched:</p>

<ul>
  <li>in the current node children</li>
  <li>in the current node siblings</li>
  <li>in the current node parents</li>
  <li>? (to be further defined)</li>
</ul>

<h3 id="options">Options</h3>

<p>The <strong>option</strong> is the basic unit of configurability.</p>

<h4 id="single-choice">Single choice</h4>

<p>Typically each option corresponds to a single choice that a user can make. For example there may be an option to control whether or not assertions are enabled, and the RTOS may provide an option corresponding to the number of scheduling priority levels in the system. Options can control very small amounts of code such as whether or not a function gets inlined. They can also control quite large amounts of code, for example whether or not the tracing supports is enabled or not.</p>

<p>Many options are straightforward, and the user only gets to choose whether the option is enabled or disabled. Some options are more complicated, and have values, for example the number of scheduling priority levels is a number that should be within a certain range.</p>

<h4 id="sensible-defaults">Sensible defaults</h4>

<p>Options should always start off with a sensible default setting, so that it is not necessary for users to make hundreds of decisions before any work can start on developing the application. Once the application is running the various configuration options can be used to tune the build for the specific needs of the application.</p>

<h4 id="read-only-1">Read-only</h4>

<p>The component framework allows for options that are not directly user-modifiable. Consider the case of processor endianness: some processors are always big-endian or always little-endian, while with other processors there is a choice. Depending on the user’s choice of target hardware, endianness may or may not be user-modifiable.</p>

<h4 id="hierarchy-1">Hierarchy</h4>

<p>Options are leafs in the objects hierarchy, with components or packages as parents. Options cannot include other children objects.</p>

<h4 id="activeinactive">Active/inactive</h4>

<p>Options can be <em>active/inactive</em>. Inactive options are not shown in the current virtual hierarchy. If the full tree is displayed, inactive options are shown as grey nodes, and the user cannot enable/disable them, or change the value for options with attached data. An option is automatically inactive if its parent object is inactive or disabled.</p>

<h4 id="enableddisabled">Enabled/disabled</h4>

<p>Active options can be <em>enabled/disabled</em> by users, usually via a graphical tool. Simple options are boolean, and the enable/disable status is also the value associated with them. More complex options can have different types, and values according to these types.</p>

<h3 id="components-1">Components</h3>

<p>Components are containers of other objects.</p>

<p>A <strong>component</strong> is a unit of functionality such as a particular RTOS scheduler or a device driver for a specific device. A component is also a configuration option in that users may want to enable or disable all the functionality of a component. For example, if a particular device on the target hardware is not going to be used by the application, directly or indirectly, then there is no point in having a device driver for it. Furthermore disabling the device driver should reduce the memory requirements for both code and data.</p>

<h4 id="hierarchy-2">Hierarchy</h4>

<p>Components may contain further configuration objects. In the case of a device driver, there may be options to control the exact behaviour of that driver. These will of course be irrelevant if the driver as a whole is disabled. More generally options and components live in a hierarchy, where any component or package can contain options specific to that component and further sub-components.</p>

<h4 id="activeinactive-1">Active/inactive</h4>

<p>Components can be <em>active/inactive</em>. Inactive components are not shown in the current virtual hierarchy. If the full tree is displayed, inactive components are shown as grey in the interface, and the user cannot enable/disable them, or change the value if not boolean. A component is automatically inactive if its parent object is inactive or disabled.</p>

<h4 id="enableddisabled-1">Enabled/disabled</h4>

<p>Active components can be <em>enabled/disabled</em> by users, usually via a graphical tool, similar to options. More complex options can have different types, and values according to these types.</p>

<h3 id="files">Files</h3>

<p>Files are a special type of components, that map to physical files.</p>

<h4 id="node-name-1">Node name</h4>

<p>The node name of a file is exactly the file name, as represented in the file system.</p>

<h4 id="hierarchy-3">Hierarchy</h4>

<p>Files are generally children of components, but may also have other components as children.</p>

<h4 id="activeinactive-2">Active/inactive</h4>

<p>Files can be <em>active/inactive</em>. Inactive files are not shown in the current virtual hierarchy. If the full tree is displayed, inactive files are shown as grey in the interface, and the user cannot enable/disable them. A file is automatically inactive if its parent object is inactive or disabled.</p>

<h4 id="enableddisabled-2">Enabled/disabled</h4>

<p>Active files can be <em>enabled/disabled</em> by users, usually via a graphical tool, similar to options.</p>

<p>Enabled files are generally included in the build (copied or linked to the project). Disabled files behave like non-existing for the project and any reference to disabled files should break the build.</p>

<h3 id="packages-1">Packages</h3>

<p>A package is a special type of component. Specifically, a package is the unit of distribution of components.</p>

<p>If the package is distributed as a binary file, it can be unpacked and installed (added to the components repository) using the appropriate tool. Afterwards it is possible to uninstall that package, or to install a later version.</p>

<h4 id="loadedunloaded">Loaded/unloaded</h4>

<p>Packages can be <em>loaded</em> or <em>not loaded</em>. Generally, for a given configuration, it makes no sense for the tools to load the details of every single package that has been installed. For example, if the target board explicitly requires to use the STM32F407VG processor, then there is no point in loading packages for other processors and displaying choices to the user which are not relevant. Therefore <em>loading</em> a package means loading its configuration data into the appropriate tool, and making it available for user choices (for example showing it in the graphical user interface); a package not loaded by a configuration simply does not exist for that configuration, and none of its resources can be used.</p>

<p>Packages maintain a dependencies list; <em>loading</em> a package also means loading all dependent packages, recursively.</p>

<p>Selecting which packages are loaded is the first step of the configuration wizard, as a mandatory step to select the target processor and possibly board.</p>

<h4 id="versioning">Versioning</h4>

<p>For repeatability reasons it is required for some packages to depend on a specific version of a package. For this to work it must be possible to select the particular version of a package that should be loaded. Since multiple different packages may depend each on a different versions of a package, multiple versions of the same package must be available to the component framework at the same time.</p>

<h4 id="hierarchy-4">Hierarchy</h4>

<p>Packages can also be organised hierarchically, and loading of a package automatically loads all parent packages, up to the repository root.</p>

<h4 id="core-distribution">Core distribution</h4>

<p>The core distribution may come with a number of packages such as CMSIS, startup files, the RTOS, debug infrastructure. Other packages such as network stacks can come from various different sources and can be installed alongside the core distribution upon request.</p>

<h3 id="configurations">Configurations</h3>

<p>A <strong>configuration</strong> is a persistent collection of user choices, applied on top of a collection of choices made by the component designer. The various tools that make up the component framework deal with configurations. Users can create a new configuration, manage a configuration, and use a configuration to generate a build tree prior to building an artefact (application or library). A configuration includes details such as which packages are loaded, plus finer-grained information such as which options in those packages have been enabled or disabled by the user and what values were assigned to typed versions.</p>

<h3 id="targets">Targets</h3>

<p>The <strong>target</strong> is the specific piece of hardware on which the application is expected to run. This may be an off-the-shelf evaluation board, a piece of custom hardware intended for a specific application, or it could be something like a simulator or a synthetic platform. One of the steps when creating a new configuration is the need to select the target. The component framework will map this on to a set of packages that are used to populate the configuration, typically specific startup files, device driver packages, and in addition it may cause certain options to be changed from their default settings to something more appropriate for the specified target.</p>

<h3 id="templates">Templates</h3>

<p>A <strong>template</strong> is a partial configuration, aimed at providing users with an appropriate starting point. XCDL/xPack repositories should be shipped with a small number of templates, which correspond closely to common ways of using them.</p>

<p>There is a minimal template which provides very little functionality, just enough to bootstrap the hardware and then jump directly to the application code. The default template adds additional functionality, for example it causes a RTOS and various library packages to be used as well. Creating a new configuration typically involves specifying a template as well as a target, resulting in a configuration that can be built and linked with the application code and that will run on the actual hardware. It is then possible to fine-tune configuration options to produce something that better matches the specific requirements of the application.</p>

<h3 id="properties">Properties</h3>

<p>The component framework needs a certain amount of information about each XCDL object. For example it needs to know what the legal values are, what the default should be, where to find the on-line documentation if the user needs to consult that in order to make a decision, and so on. These are all <strong>properties</strong> of the object. Every object (including components and packages) consists of a name and a set of properties.</p>

<h3 id="consequences">Consequences</h3>

<p>As in real life, choices must have consequences. For example, for some configurations the main end product is an executable, for others a library, so the consequences of a user choice must affect the build process. This happens in two main ways. First, options can affect which files get built and end up in the executable or library. Second, details of the current option settings get written into various configuration header files using C preprocessor <code>#define</code> directives, and package source code can <code>#include</code> these configuration headers and adapt accordingly. This allows options to affect a package at a very fine grain, at the level of individual lines in a source file if desired. There may be other consequences as well, for example there are options to control the compiler flags that get used during the build process.</p>

<h3 id="constraints">Constraints</h3>

<p>Configuration choices are not independent. The C library can provide thread-safe implementations of functions like <code>rand()</code>, but only if the RTOS provides support for per-thread data. This is a constraint: the C library option has a requirement on the RTOS. A typical configuration involves a considerable number of constraints, of varying complexity: many constraints are straightforward, <em>option A requires option B</em>, or <em>option C precludes option D</em>. Other constraints can be more complicated, for example <em>option E may require the presence of a RTOS scheduler</em> but does not care whether it is the bitmap scheduler, the mlqueue scheduler, or something else.</p>

<p>Another type of constraint involves the values that can be used for certain options. For example there is a RTOS option related to the number of scheduling levels, and there is a legal values constraint on this option: specifying zero or a negative number for the number of scheduling levels makes no sense.</p>

<h3 id="conflicts">Conflicts</h3>

<p>As the user manipulates options (enables/disables them) it is possible to end up with an invalid configuration, where one or more constraints are not satisfied. For example if RTOS per-thread data is disabled but the C library’s thread-safety options are left enabled then there are unsatisfied constraints, also known as <strong>conflicts</strong>. Such conflicts will be reported by the configuration tools. The presence of some conflicts may prevent users from building the project, but some may not, and in these cases the consequences are undefined: there may be compile-time failures, there may be link-time failures, the application may completely fail to run, or the application may run most of the time but once in a while there will be a strange failure… Typically users will want to resolve all conflicts before continuing.</p>

<h4 id="inference-engine">Inference engine</h4>

<p>To make things easier for the user, the configuration tools contain an inference engine. This can examine a conflict in a particular configuration and try to figure out some way of resolving the conflict. Depending on the particular tool being used, the inference engine may get invoked automatically at certain times or the user may need to invoke it explicitly. Also depending on the tool, the inference engine may apply any solutions it finds automatically or it may request user confirmation.</p>

<h2 id="credits">Credits</h2>

<p>The initial content of this page was based on <em>Chapter 1. Overview</em> of <em>The eCos Component Writer’s Guide</em>, by Bart Veer and John Dallaway, published in 2001.</p>








<ul class="share-buttons">
  <li><div class="fb-share-button" data-href="http://ilg-ul.github.io/guide/concepts/" data-layout="button"></div></li>
  <li><div class="tw-share-button"><a href="https://twitter.com/share" class="twitter-share-button" data-count="none">Tweet</a></div></li>
</ul>



      </div>

    </div>
  </div>

</div>

<div class="container">

  <div class="site-footer">
  <div class="site-footer-links left">
    <ul>
  <li>© 2015 Liviu Ionescu</li>
  <li>Hosted on GitHub</li>
  <li><a href="/feed.xml"><img src="/assets/images/feed-20.png" alt="RSS" /></a></li>
</ul>


  </div>
  <a href="https://github.com/xcdl/xcdl-go" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
  </a>
  <div class="site-footer-links right">
    <ul>
  <li><a href="/">Home</a></li>
  <li><a href="/blog/">News</a></li>
  <li><a href="https://github.com/xcdl/xcdl-go/releases">Releases</a></li>
  <li><a href="https://github.com/xcdl/xcdl-go/issues">Support</a></li>
  <li><a href="/about/">About</a></li>
</ul>

  </div>
</div>


</div>

</body>
</html>
